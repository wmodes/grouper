
import sys
import csv
from pathlib import Path
from importlib import import_module
import pprint
import re
import os

# Read raw CSV data file
# Make basic edits to raw data
#   Remove the timestamp column (:%s/^[^,]*,//)
#   Join the name and email columns (:%s/,/ - /)
#   Remove " - Hella" and " - Meh" from the data (:%s/ - \(Meh\|Hella\)//g)
#   Remove " - Best" and " - Worst" from the data (:%s/ - \(Best\|Worst\)//g))
#   Remove " - Little" and " - Lots" from the data (:%s/ - \(Little\|Lots\)//g))
#   Check for the unlikely event of blank fields (:%s/,,/,1,/g)
#   Delete human readable notes fields
# Read config file
# Read conflicts file
# Build GG command options
# Run GG

DATADIR = "data"
GG = "../gatorgrouper/gatorgrouper_cli.py"

class Grouper(object):
    """
    """
    def __init__(self, args):
        # Validate command line options
        if len(args) < 4:
            self.usage()
            raise ValueError("Insufficient command line arguments provided")

        self.classname = args[1]
        self.term = args[2]
        self.numgroups = args[3]
        self.prefopt = args[4] if len(args) > 4 else ""

        self.datafile = f"{DATADIR}/{self.classname}-{self.term}.csv"
        self.prepfile = f"{DATADIR}/tmp-prep.csv"
        self.preffile = f"{DATADIR}/{self.classname}-{self.term}-pref.csv"

        self.student_data = []
        self.cli_opts = ''
        self.config_data = {}
        self.field_order = []

        self.exclude_fields = ['email', 'pref_yes', 'pref_no']

    def read_class_data(self):
        """
        Reads the class data from a CSV file.
        The first four lines of the file are reserved for configuration data:
        - The first line (field names line) lists the names of the data fields.
        - The second line specifies the match type for each field.
        - The third line contains the scores for each field.
        The rest of the file contains student data.
        """
        print('## Reading class data')
        with open(self.datafile, newline='') as csvfile:
            reader = csv.reader(csvfile)
            
            # discard the first line which is google form's autogenerated header
            next(reader)

            # Read 'Our Field Name' line and store field order
            field_names_line = next(reader)
            valid_columns = []
            for i, field in enumerate(field_names_line):
                if field:
                    valid_columns.append(i)
                    # Add field to field_order list
                    self.field_order.append(field)  
            
            # Read the next two lines for 'Match Type' and 'Score'
            # Only process these for columns identified as valid
            match_types_line = next(reader)
            # print("DEBUG: match_types_line: ", match_types_line)
            scores_line = next(reader)
            # print("DEBUG: scores_line: ", scores_line)
            for i in valid_columns:
                field = field_names_line[i]
                self.config_data[field] = {
                    'match_type': match_types_line[i],
                    'score': float(scores_line[i]) if scores_line[i] else 0
                }

            # Process the remaining lines in the file as student data
            # Create a dictionary for each student, using valid field names
            # as keys and corresponding values from the row
            for row in reader:
                # Map each value in the row to its corresponding field name
                # Include only those fields that are valid (based on field names line)
                student_data = {field_names_line[i]: value for i, value in enumerate(row) if i in valid_columns}
                
                # Add the processed student data to the class_data list
                # but only if the row is not empty
                if student_data:  
                    self.student_data.append(student_data)
        # print(f"DEBUG: {pprint.pformat(self.config_data)}")

    def prep_data(self):
        """
        Prepares the class data for grouping.
        This includes:
        - Cleaning up the 'name' field by removing unusual characters.
        - Creating a new 'id' column by combining 'name' and 'email'.
        - Updating self.config_data to include the 'id' column.
        - Processing other fields based on their match type and extracting numerical values.
        """
        print('## Prepping class data')
        # process student data, one record at a time
        for student in self.student_data:
            # Clean up the 'name' field by removing unusual characters
            student['name'] = re.sub(r'[^,-.@<>\w\s]', '', student.get('name', ''))

            # Combine 'name' and 'email' into 'name'' column
            email = student.get('email', '')
            student['name'] = f"{student['name']} <{email}>"
            # remove the 'email' column 
            # del student['email']

            # Iterate over all fields, skipping those with match type 'id'
            for key in student:
                if self.config_data.get(key, {}).get('match_type') == 'id':
                    continue;
                if self.config_data.get(key, {}).get('match_type') == 'pref':
                    continue;
                field_value = student[key]
                # Extract a number if one exists
                extract_num = re.findall(r'\d+', field_value)
                if extract_num:
                    student[key] = int(extract_num[0])
                # Assign 1 for text value (but no number)
                elif field_value:
                    student[key] = 1
                # Assign 0 if there is no value
                else:
                    student[key] = 0
        
        # remove the "email" column from the config data and field_order
        # del self.config_data['email']
        # self.field_order.remove('email')

        # print(f"DEBUG: {pprint.pformat(self.class_data)}")
        # print(f"DEBUG: {self.field_order}")

    def write_prepfile(self):
        """
        Writes the prepared class data to a CSV file in a format compatible with GatorGrouper.
        Excludes fields listed in self.exclude_fields from the output.
        """
        print('## Writing class data tmp file')
        with open(self.prepfile, 'w', newline='') as csvfile:
            # Filter out excluded fields from field_order for the header
            filtered_field_order = [field for field in self.field_order if field not in self.exclude_fields]

            writer = csv.DictWriter(csvfile, fieldnames=filtered_field_order, quotechar='"', quoting=csv.QUOTE_NONNUMERIC)

            # Write the header
            writer.writeheader()

            # Write the student data
            for student in self.student_data:
                # Filter out excluded fields from each student's data
                filtered_student_data = {k: v for k, v in student.items() if k not in self.exclude_fields}
                # Write the filtered data
                writer.writerow(filtered_student_data)

    def pref_lookup(self, search_name):
        """
        Looks up a name in class_data and returns the corresponding 'name' field.
        Performs a more precise partial match, focusing on substantial name parts.
        """
        search_name = search_name.lower()  # Lowercase for case-insensitive comparison
        for student in self.student_data:
            # Extract the name part (excluding email) and split into parts
            student_name_parts = student['name'].split('<')[0].lower().strip().split()
            search_name_parts = search_name.split()
            # Check for substantial overlap between search name parts and student name parts
            if any(part in student_name_parts for part in search_name_parts) or \
            any(part in search_name_parts for part in student_name_parts):
                return student['name']
        return None


    def prep_preferences(self):
        """
        Processes preference data and writes it to self.preffile.
        """
        print('## Compiling preferences')
        with open(self.preffile, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)

            # Iterate over each student
            for student in self.student_data:
                # Process positive preferences (pref_yes)
                if 'pref_yes' in student and student['pref_yes'].strip():
                    for pref_name in student['pref_yes'].split(','):
                        match_name = self.pref_lookup(pref_name.strip())
                        if match_name:
                            writer.writerow([student['name'], match_name, self.config_data['pref_yes']['score']])
                        else:
                            print(f"\tWarning: No match found for {pref_name} in {student['name']}")

                # Process negative preferences (pref_no)
                if 'pref_no' in student and student['pref_no'].strip(): 
                    for pref_name in student['pref_no'].split(','):
                        match_name = self.pref_lookup(pref_name.strip())
                        if match_name:
                            writer.writerow([student['name'], match_name, -self.config_data['pref_no']['score']])
                        else:
                            print(f"\tWarning: No match found for {pref_name} in {student['name']}")

    def build_cl_opt(self):
        """
        Builds the command line options for GatorGrouper based on the processed data.
        Sample command line for gatorgrouper:

            python gatorgrouper_cli.py --file data/test-prep.csv --num-group 4 --method graph --objective-measures diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff --objective-weights -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 10 10 10 -15 5 -5 5 3 -3 -3 -3 -3 -3 -3 -3 -3 -3 --preferences data/test-pref.csv --preferences-weight -100 --preferences-weight-match 100
        """
        print('## Compiling options')
        # Basic GatorGrouper command with file and group number
        cli_opts = [f"--file {self.prepfile}", f"--num-group {self.numgroups}"]

        # Add method and objectives
        cli_opts.append("--method graph")  # Example: using graph method
        cli_opts.extend(self.build_objective_opts())

        # Handle preferences if applicable
        if self.prefopt:
            cli_opts.extend(self.build_preference_opts())

        # Convert list of options to a single string
        self.cli_opts = ' '.join(cli_opts)
        print(f"DEBUG: CLI OPTS: {self.cli_opts}")

    def build_objective_opts(self):
        """
        Constructs the objective measures and weights options for the GatorGrouper command.
        """
        # Example structure. Adapt based on how you've structured self.config_data
        objective_measures = []
        objective_weights = []
        for field, config in self.config_data.items():
            objective_measures.append("diff")  # Assuming 'diff' for all fields for now
            objective_weights.append(str(config['score']))

        return ["--objective-measures " + ' '.join(objective_measures),
                "--objective-weights " + ' '.join(objective_weights)]

    def build_preference_opts(self):
        """
        Constructs the preference options for the GatorGrouper command.
        """
        # Example structure. Modify based on the actual preference handling in GatorGrouper
        return [f"--preferences {self.preffile}",
                f"--preferences-weight {self.config_data['pref_yes']['score']}",
                f"--preferences-weight-match -{self.config_data['pref_no']['score']}"]

    def run_gatorgrouper(self):
        print("## Generating groups")
        command = f"python3 {GG} {self.cli_opts}"
        os.system(command)

    def usage(self):
        print (f"Usage: {sys.argv[0]} classname term groups [pref]")
        print ("where:")
        print ("   classname: class name, e.g., art101")
        print ("   term: current term, e.g., f21, s22")
        print ("   groups: number of groups (has to be a power of 2)")
        print ("   pref: any value indicates a pref file has been written in data dir, e.g., art101-pref.csv")
        print ("      Pref file format is: Dominic Jones,Hannah McAllister,-100")
        print ("Requirements:")
        print ("   * A survey file exists in the data dir corresponding to the term, e.g., art101s22")
        print ("   * A pref file exists in the data dir for this term, e.g., art101s22-pref")


    def main(self):
        print("\nCreating a k-way graph partition with the Kernighan-Lin algorithm to determine the grouping of students based on their preferences for working with other students and compatibility with other classmates. (Ref: https://github.com/GatorIncubator/gatorgrouper)\n")
        # self.read_class_config()
        # self.prep_fields()
        self.read_class_data()
        self.prep_data()
        self.write_prepfile()
        if (self.prefopt):
            self.prep_preferences()
        self.build_cl_opt()
        self.run_gatorgrouper()


if __name__ == "__main__":
    # print(f"DEBUG: argv: {sys.argv}")
    grouper = Grouper(sys.argv)
    grouper.main()
